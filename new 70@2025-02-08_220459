In Kubernetes, **Deployment** and **Service** YAML files are used to define and manage applications and their network access. Below are examples of how to define these resources.

### **1. Deployment YAML**

A **Deployment** defines a set of replicas for a specific application, and it manages the application's lifecycle, including scaling and rolling updates.

#### Example Deployment YAML for a Simple Web Application

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app-deployment
  labels:
    app: web-app
spec:
  replicas: 3  # Number of pod replicas
  selector:
    matchLabels:
      app: web-app
  template:
    metadata:
      labels:
        app: web-app
    spec:
      containers:
      - name: web-app-container
        image: nginx:latest  # The image to use for the container
        ports:
        - containerPort: 80  # Port the container will expose
```

### Explanation of the Deployment YAML:

- **apiVersion**: Specifies the Kubernetes API version (here, `apps/v1`).
- **kind**: The type of resource (here, `Deployment`).
- **metadata**: Defines metadata for the deployment like `name` and `labels`.
- **spec**:
  - **replicas**: The number of pod replicas you want to maintain (in this case, 3 replicas).
  - **selector**: The selector ensures the deployment only manages pods with matching labels.
  - **template**: The pod template used to create new pods, specifying the container's image and port.
  - **containers**: Specifies the container within the pod, including the `image` to use and the port to expose (`containerPort: 80`).

---

### **2. Service YAML**

A **Service** exposes a set of pods to the network, allowing communication between pods and external clients. It provides load balancing and stable DNS names for accessing the pods.

#### Example Service YAML for Exposing the Web Application

```yaml
apiVersion: v1
kind: Service
metadata:
  name: web-app-service
spec:
  selector:
    app: web-app  # Selector that matches pods from the deployment
  ports:
    - protocol: TCP
      port: 80   # Port on the service
      targetPort: 80  # Port on the container (as defined in the deployment)
  type: LoadBalancer  # Exposes the service externally (if supported by the cloud provider)
```

### Explanation of the Service YAML:

- **apiVersion**: The API version of the resource (here, `v1`).
- **kind**: The type of resource (here, `Service`).
- **metadata**: Metadata about the service (e.g., `name` of the service).
- **spec**:
  - **selector**: This connects the service to the pods by matching labels. In this case, it targets pods with the label `app: web-app` (from the deployment).
  - **ports**:
    - **port**: The port the service exposes to external clients (80).
    - **targetPort**: The port on the container to forward traffic to (80, as specified in the deployment).
    - **protocol**: Protocol for communication (usually TCP for web applications).
  - **type**: Defines the service type. `LoadBalancer` exposes the service externally (in a cloud provider like AWS, it will create an external load balancer). Other options 
  include `ClusterIP` (default) and `NodePort`.

---

### **3. Combine Both Deployment and Service in One YAML File**

You can also define both the Deployment and Service in a single file. Hereâ€™s an example that includes both the Deployment and the Service:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app-deployment
  labels:
    app: web-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web-app
  template:
    metadata:
      labels:
        app: web-app
    spec:
      containers:
      - name: web-app-container
        image: nginx:latest
        ports:
        - containerPort: 80

---
apiVersion: v1
kind: Service
metadata:
  name: web-app-service
spec:
  selector:
    app: web-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: LoadBalancer
```

### Steps to Apply the YAML Files:

1. Save the YAML files (you can combine them or keep them separate).
2. Apply them using `kubectl`:

```bash
kubectl apply -f <your-yaml-file>.yaml
```

For the combined file example, you can use:

```bash
kubectl apply -f deployment-and-service.yaml
```

---

### Summary:
- **Deployment** YAML defines the configuration for deploying a set of pods (e.g., web application containers).
- **Service** YAML defines how the deployed pods should be exposed and how external traffic should access them.

By defining both the Deployment and Service, you can easily manage and scale your applications within a Kubernetes cluster, and expose them securely to the outside world.2
